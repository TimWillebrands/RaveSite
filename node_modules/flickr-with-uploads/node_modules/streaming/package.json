{
  "name": "streaming",
  "version": "0.3.8",
  "description": "Transforms and other streaming helpers",
  "keywords": [
    "streaming",
    "streams",
    "streams2",
    "transform",
    "duplex",
    "readable",
    "writable"
  ],
  "homepage": "https://github.com/chbrown/streaming",
  "repository": {
    "type": "git",
    "url": "git://github.com/chbrown/streaming.git"
  },
  "author": {
    "name": "Christopher Brown",
    "email": "io@henrian.com"
  },
  "license": "MIT",
  "dependencies": {
    "glob": "*"
  },
  "devDependencies": {
    "tap": "*"
  },
  "scripts": {
    "test": "tap test"
  },
  "readme": "# streaming\n\nA few stream helpers, abiding by the new-style Node.js stream standards (\"Streams2\").\n\n    npm install streaming\n\n\n### `streaming.Glob`\n\n`new Glob(pattern, options)` inherits `stream.Readable`\n\n* _readableState.objectMode: true\n\n\n### `streaming.json.Stringifier`\n\n`new Stringifier(replacer, space)` inherits `streaming.Splitter`\n\n* objectMode: false\n  * _writableState.objectMode: false\n  * _readableState.objectMode: true\n\n\n### `streaming.json.Parser`\n\n`new Parser()` inherits `streaming.Splitter`\n\n* objectMode: true\n\n\n### `streaming.Mapper`\n\n`new Mapper(fn)` inherits `stream.Transform`\n\n* _writableState.objectMode: true\n* _readableState.objectMode: true\n\n\n### `streaming.Queue`\n\n`new Queue(concurrency, worker)` inherits `streaming.Mapper`\n\n* _writableState.objectMode: true\n* _readableState.objectMode: true\n\nExample:\n\n```javascript\nvar streaming = require('streaming');\n\nvar lazy_worker = function(task, callback) {\n  setTimeout(function() {\n    var json = JSON.stringify(task);\n    callback(null, json.length + ' after 1s\\n');\n  }, 1000);\n};\n\nprocess.stdin\n.pipe(new streaming.Splitter())\n.pipe(new streaming.Mapper(JSON.parse))\n.pipe(new streaming.Queue(5, lazy_worker))\n.pipe(process.stdout);\n```\n\n\n### `streaming.Splitter`\n\nWhat used to be `streaming.Line` and `Rechunker` have been folder into this more generic, more flexible class.\n\n`new Splitter(split, opts)` inherits `stream.Transform`\n\n\n### `streaming.Timeout`\n\n`new Timeout(seconds, opts)` inherits `stream.Transform`\n\n### `streaming.Walk`\n\n`new Walk(root)` inherits `stream.Readable`\n\nA `streaming.Walk` will emit data that are `streaming.Walk.Node` objects. A `Node` has two fields, `.path`, which is relative to the given `root`, and `.stats`, which is a [`fs.Stats`](http://nodejs.org/api/fs.html#fs_class_fs_stats) object. `node.toString()` will return `node.path`.\n\nIt recurses the filesystem structure depth-first. If the given `root` is not a directory, it will only ever emit that file. Otherwise, if `root` is a directory, it will be emitted as a data point (just like all other directories under `root` as it comes to them). The directory entry itself will always immediately precede its children. The order of children is taken exactly as they produced by `fs.readdir`, which seems to be undefined or maybe by creation date (newest first).\n\n`fs.Stats` has helper functions `.isFile()` and `.isDirectory()`, so we can print the paths only files (ignoring directories) like this:\n\n```javascript\nvar streaming = require('streaming');\n\nvar streaming = require('./');\nvar walk = new streaming.Walk('/usr/local');\nwalk.on('error', function(err) {\n  console.error('error', err);\n  if (err.code == 'EACCES') {\n    // if the error is just \"access denied\", ignore both the error and the file.\n    // call resume() to carry on as if nothing had happened\n    walk.resume();\n  }\n  else {\n    console.error('Critical error; not resuming.');\n  }\n});\nwalk.on('data', function(node) {\n  // just skip over directories:\n  if (node.stats.isFile()) {\n    console.log(node.toString());\n  }\n});\n```\n\n\n## `stream.Transform(opts)` results:\n\n<!-- the space after each period is to allow a line break -->\n| opts. decodeStrings | opts. objectMode | _writableState. decodeStrings | _writableState. objectMode | _readableState. objectMode |\n|:----|:----|:----|:----|:----|\n| true | true | true | true | true |\n| false | true | false | true | true |\n| undefined | true | true | true | true |\n| true | false | true | false | false |\n| false | false | false | false | false |\n| undefined | false | true | false | false |\n| true | undefined | true | false | false |\n| false | undefined | false | false | false |\n| undefined | undefined | true | false | false |\n\n\n(Only `_writableState` has a `decodeStrings` field.)\n\n<!--\nvar booleans = [true, false, undefined];\nfunction log_row(values) { console.log('| ' + values.join(' | ') + ' |'); };\n(function() {\n  log_row(['decodeStrings', 'objectMode',\n    '_writableState.decodeStrings', '_writableState.objectMode', '_readableState.objectMode']);\n  booleans.forEach(function(objectMode) {\n    booleans.forEach(function(decodeStrings) {\n      var t = new stream.Transform({objectMode: objectMode, decodeStrings: decodeStrings});\n      log_row([decodeStrings, objectMode,\n        t._writableState.decodeStrings, t._writableState.objectMode, t._readableState.objectMode]);\n    });\n  })\n})();\n-->\n\n## License\n\nCopyright Â© 2013 Christopher Brown. [MIT Licensed](LICENSE).\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/chbrown/streaming/issues"
  },
  "_id": "streaming@0.3.8",
  "_from": "streaming@*"
}
